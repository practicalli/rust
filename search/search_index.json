{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Practicalli Rust","text":"<p>Practicalli Rust is a hands-on guide to using the Rust programming language throughout all the software development stages.</p> <p>Live coding videos demonstrate the Rust workflow in action, showing how to get the most out of the unique approach the language provides.</p> <p>Practical code examples are supported by discussions of the concepts behind Rust, including functional programming and effective tooling.</p> <p>Rust Language Homepage</p>"},{"location":"#rust-community","title":"Rust community","text":"<p>The Rust Book</p> <p>Rust API</p> <p> Rust blog</p> <p>Rust online playground</p>"},{"location":"assets/images/social/","title":"Social Cards","text":"<p>Social Cards are visual previews of the website that are included when sending links via social media platforms.</p> <p>Material for MkDocs is configured to generate beautiful social cards automatically, using the colors, fonts and logos defined in <code>mkdocs.yml</code></p> <p>Generated images are stored in this directory.</p>"},{"location":"editors/","title":"Editors for Rust","text":"<ul> <li>Neovim - Treesitter Rust parser, rusacea.nvim</li> <li>Emacs</li> <li>VS Code</li> <li>RustRover</li> </ul>"},{"location":"editors/#rust-lsp-server","title":"Rust LSP server","text":"<p>Editors with Rust support benefits from the rust-analyser, a Language Server Protocol (LSP) implementation for the Rust language.</p> <p>The rust-analyser server runs a static analysis of the code in a project, returning data about syntax errors and language idioms.</p> <p>Data is used by LSP clients which are found in the majority of editors (or editor extensions) to display diagnostics in the user interface.</p>"},{"location":"editors/emacs/","title":"Emacs","text":"<p>Rust-mode provides core workflow support. rustic</p>"},{"location":"editors/emacs/#rust-mode","title":"Rust-mode","text":"<p><code>rust-mode</code> makes editing Rust code with Emacs enjoyable. It requires Emacs 25 or later, and is included in both Emacs Prelude and Spacemacs by default.</p> <p>rust-mode provides:</p> <ul> <li>Syntax highlighting (for Font Lock Mode)</li> <li>Indentation</li> <li>Integration with Cargo, clippy and rustfmt</li> </ul> <p>This mode does not provide auto completion, or jumping to function / trait definitions.</p>"},{"location":"editors/emacs/#rustic-mode","title":"rustic mode","text":"<p>Rustic is based on rust-mode and provides additional features:</p> <ul> <li>cargo popup</li> <li>multiline error parsing</li> <li>translation of ANSI control sequences through   xterm-color</li> <li>async org babel</li> <li>automatic LSP configuration with   eglot or   lsp-mode</li> <li>[eask][] for testing</li> </ul> <p>rustic only shares the rust-mode code from rust-mode.el and rust-utils.el.</p>"},{"location":"editors/emacs/#lsp-client","title":"LSP client","text":""},{"location":"editors/neovim/","title":"Neovim for Rust","text":"<p>Neovim provides excellent syntax support via the Treesiter parser for rust.</p> <p>rust-analyzer provides an LSP server that returns diagnostics to the Neovim LSP Client and/or rustaceanvim</p> <p>rustaceanvim provides extensive features for rust development and integrates with LSP clients.</p> Practicalli Astro <p>Add Astrocommunity Rust Pack</p> <pre><code>  { import = \"astrocommunity.pack.rust\" },\n</code></pre> <p>Rust support provided via the Astrocommunity Rust pack</p> <ul> <li>rust Treesitter parser</li> <li>LSP support via rust-analyzer &amp; cargo clippy</li> <li>DAP (debug) via codelldb (mason installl)</li> <li>rustaceanvim for rust specific tooling via rust-analyzer</li> <li>crates.nvim for crate management and completion</li> <li>TOML language support</li> <li>neotest is a Neovim framework for test runners, i.e. rustaceanvim.neotest</li> </ul> <p><code>rust-analyzer</code> shold be added via the <code>rustup</code> tool</p> <p>Install rust-analyzer via rustup</p> <pre><code>rustup component add rust-analyzer\n</code></pre> <pre><code>\u276f rustup component add rust-analyzer\ninfo: downloading component 'rust-analyzer'\ninfo: installing component 'rust-analyzer'\n</code></pre>"},{"location":"editors/rustrover/","title":"RustRover","text":"<p>RustRover</p>"},{"location":"install/","title":"Install Rust","text":"<p>rustup is the defacto installer and version management tool for Rust.</p> Rustup Install Script <pre><code>curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh\n</code></pre> Install output <pre><code>\u276f curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh\ninfo: downloading installer\n\nWelcome to Rust!\n\nThis will download and install the official compiler for the Rust\nprogramming language, and its package manager, Cargo.\n\nRustup metadata and toolchains will be installed into the Rustup\nhome directory, located at:\n\n  /home/practicalli/.rustup\n\nThis can be modified with the RUSTUP_HOME environment variable.\n\nThe Cargo home directory is located at:\n\n  /home/practicalli/.cargo\n\nThis can be modified with the CARGO_HOME environment variable.\n\nThe cargo, rustc, rustup and other commands will be added to\nCargo's bin directory, located at:\n\n  /home/practicalli/.cargo/bin\n\nThis path will then be added to your PATH environment variable by\nmodifying the profile files located at:\n\n  /home/practicalli/.profile\n  /home/practicalli/.bashrc\n  /home/practicalli/.config/zsh/.zshenv\n\nYou can uninstall at any time with rustup self uninstall and\nthese changes will be reverted.\n\nCurrent installation options:\n\n\n   default host triple: x86_64-unknown-linux-gnu\n     default toolchain: stable (default)\n               profile: default\n  modify PATH variable: yes\n\n1) Proceed with standard installation (default - just press enter)\n2) Customize installation\n3) Cancel installation\n\ninfo: profile set to 'default'\ninfo: default host triple is x86_64-unknown-linux-gnu\ninfo: syncing channel updates for 'stable-x86_64-unknown-linux-gnu'\ninfo: latest update on 2025-05-15, rust version 1.87.0 (17067e9ac 2025-05-09)\ninfo: downloading component 'cargo'\ninfo: downloading component 'clippy'\ninfo: downloading component 'rust-docs'\n 19.9 MiB /  19.9 MiB (100 %)  13.6 MiB/s in  1s\ninfo: downloading component 'rust-std'\n 29.4 MiB /  29.4 MiB (100 %)  15.2 MiB/s in  2s\ninfo: downloading component 'rustc'\n 76.3 MiB /  76.3 MiB (100 %)  14.1 MiB/s in  5s\ninfo: downloading component 'rustfmt'\ninfo: installing component 'cargo'\ninfo: installing component 'clippy'\ninfo: installing component 'rust-docs'\n 19.9 MiB /  19.9 MiB (100 %)   5.9 MiB/s in  2s\ninfo: installing component 'rust-std'\n 29.4 MiB /  29.4 MiB (100 %)   9.4 MiB/s in  3s\ninfo: installing component 'rustc'\n 76.3 MiB /  76.3 MiB (100 %)  10.9 MiB/s in  7s\ninfo: installing component 'rustfmt'\ninfo: default toolchain set to 'stable-x86_64-unknown-linux-gnu'\n\n  stable-x86_64-unknown-linux-gnu installed - rustc 1.87.0 (17067e9ac 2025-05-09)\n\n\nRust is installed now. Great!\n\nTo get started you may need to restart your current shell.\nThis would reload your PATH environment variable to include\nCargo's bin directory (/home/practicalli/.rust/cargo/bin).\n\nTo configure your current shell, you need to source\nthe corresponding env file under /home/practicalli/.rust/cargo/.\n\nThis is usually done by running one of the following (note the leading DOT):\n. \"/home/practicalli/.rust/cargo/env\"            # For sh/bash/zsh/ash/dash/pdksh\nsource \"/home/practicalli/.rust/cargo/env.fish\"  # For fish\nsource $\"/home/practicalli/.rust/cargo/env.nu\"   # For nushell\n</code></pre> Custom install locations <p>Set <code>RUSTUP_HOME</code> and <code>CARGO_HOME</code> environment variables to use a custom location.</p> ~/.zshrc<pre><code># Rust Lang Development tools\nexport RUSTUP_HOME=\"${RUSTUP_HOME:=$HOME/.config/rust/rustup}\"\nexport CARGO_HOME=\"${CARGO_HOME:=$HOME/.config/rust/cargo}\"\n</code></pre> <pre><code>\u276f curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh\ninfo: downloading installer\n\nWelcome to Rust!\n\nThis will download and install the official compiler for the Rust\nprogramming language, and its package manager, Cargo.\n\nRustup metadata and toolchains will be installed into the Rustup\nhome directory, located at:\n\n  /home/practicalli/.config/rust/rustup/\n\nThis can be modified with the RUSTUP_HOME environment variable.\n\nThe Cargo home directory is located at:\n\n  /home/practicalli/.config/rust/cargo/\n\nThis can be modified with the CARGO_HOME environment variable.\n\nThe cargo, rustc, rustup and other commands will be added to\nCargo's bin directory, located at:\n\n  /home/practicalli/.config/rust/cargo/bin\n\nThis path will then be added to your PATH environment variable by\nmodifying the profile files located at:\n\n  /home/practicalli/.profile\n  /home/practicalli/.bashrc\n  /home/practicalli/.config/zsh/.zshenv\n\nYou can uninstall at any time with rustup self uninstall and\nthese changes will be reverted.\n\nCurrent installation options:\n\n\n   default host triple: x86_64-unknown-linux-gnu\n     default toolchain: stable (default)\n               profile: default\n  modify PATH variable: yes\n\n1) Proceed with standard installation (default - just press enter)\n2) Customize installation\n3) Cancel installation\n\n\ninfo: profile set to 'default'\ninfo: default host triple is x86_64-unknown-linux-gnu\ninfo: syncing channel updates for 'stable-x86_64-unknown-linux-gnu'\ninfo: latest update on 2025-05-15, rust version 1.87.0 (17067e9ac 2025-05-09)\ninfo: downloading component 'cargo'\ninfo: downloading component 'clippy'\ninfo: downloading component 'rust-docs'\n 19.9 MiB /  19.9 MiB (100 %)  13.6 MiB/s in  1s\ninfo: downloading component 'rust-std'\n 29.4 MiB /  29.4 MiB (100 %)  15.2 MiB/s in  2s\ninfo: downloading component 'rustc'\n 76.3 MiB /  76.3 MiB (100 %)  14.1 MiB/s in  5s\ninfo: downloading component 'rustfmt'\ninfo: installing component 'cargo'\ninfo: installing component 'clippy'\ninfo: installing component 'rust-docs'\n 19.9 MiB /  19.9 MiB (100 %)   5.9 MiB/s in  2s\ninfo: installing component 'rust-std'\n 29.4 MiB /  29.4 MiB (100 %)   9.4 MiB/s in  3s\ninfo: installing component 'rustc'\n 76.3 MiB /  76.3 MiB (100 %)  10.9 MiB/s in  7s\ninfo: installing component 'rustfmt'\ninfo: default toolchain set to 'stable-x86_64-unknown-linux-gnu'\n\n  stable-x86_64-unknown-linux-gnu installed - rustc 1.87.0 (17067e9ac 2025-05-09)\n\n\nRust is installed now. Great!\n\nTo get started you may need to restart your current shell.\nThis would reload your PATH environment variable to include\nCargo's bin directory (/home/practicalli/.config/rust/cargo/bin).\n\nTo configure your current shell, you need to source\nthe corresponding env file under /home/practicalli/.config/rust/cargo.\n\nThis is usually done by running one of the following (note the leading DOT):\n. \"/home/practicalli/.config/rust/cargo/env\"            # For sh/bash/zsh/ash/dash/pdksh\nsource \"/home/practicalli/.config/rust/cargo/env.fish\"  # For fish\nsource $\"/home/practicalli/.config/rust/cargo/env.nu\"  # For nushell\n</code></pre>"},{"location":"install/#confirm-install","title":"Confirm Install","text":"<p><code>cargo --version</code> command in a terminal to test Rust and Cargo installed</p>"},{"location":"install/#tools","title":"Tools","text":"<p>The Rustup script installs several tools</p> <ul> <li>rust : version 1.87.0 (17067e9ac 2025-05-09)</li> <li>rustc :</li> <li>rustfmt :</li> <li>rust-std :</li> <li>rust-docs :</li> <li>cargo :</li> <li>clippy :</li> </ul>"},{"location":"install/#update","title":"Update","text":"<pre><code>rustup update\n</code></pre> <p>clangd for faster compilation speed ?</p>"},{"location":"introduction/features/","title":"Rust Features","text":"<p>Rust is a programming language built to be fast, secure and reliable.</p> <p>Rust is a statically and strongly typed systems programming language.</p> <p>Statically typed means all types are known at compile-time. Strongly typed means types are designed to make it harder to write incorrect programs.</p> <p>A successful compilation provides a high guarantee of correctness.</p> <p>Rust is safe by default; all memory accesses are checked. It is not possible to corrupt memory by accident.</p> <p>The unifying principles behind Rust are:</p> <ul> <li>strictly enforcing safe borrowing of data</li> <li>functions, methods and closures to operate on data</li> <li>tuples, structs and enums to aggregate data</li> <li>pattern matching to select and destructure data</li> <li>traits to define behaviour on data</li> </ul> <p>There is a fast-growing ecosystem of available libraries through Cargo to complement the standard library.</p>"},{"location":"introduction/features/#run-without-crash","title":"Run without Crash","text":"<p>Code should run without crashing, from the very first time it is run</p> <p>Rust is a statically typed language and leaves almost no room for errors that would cause a program to crash.</p>"},{"location":"introduction/features/#fast-runtime-execution","title":"Fast runtime execution","text":"<p>Rust is extremely fast when it comes to execution time.</p> <p>Zero-cost abstractions \u2014</p> <p>Rust code is compiled into Assembly using the LLVM back-end (also used by C).</p> <p>Programming features like Generics and Collections do not come with runtime cost; it will only be slower to compile. (Source: stackoverflow).</p> <p>Builds optimized code for Generics</p> <p>Rust\u2019s compiler can smartly identify the generic code and optimize for each specific type</p>"},{"location":"introduction/features/#compilation-errors","title":"Compilation Errors","text":"<p>Rust\u2019s compiler gives excellent feedback in its error messages.</p> <p>The compiler may offer example code that can be used to resolve an error.</p>"},{"location":"introduction/features/#documentation","title":"Documentation","text":"<p>Rust has an amazing documentation and a tutorial guide called The Rust Book.</p>"},{"location":"introduction/features/#areas-of-use","title":"Areas of use","text":"<ul> <li>Server-side and other backend applications</li> <li>Cloud computing applications, services, and infrastructure</li> <li>Distributed systems</li> <li>Computer networking</li> <li>Computer security</li> <li>Embedded development</li> <li>Game development</li> <li>Web frontends (including WebAssembly)</li> </ul>"},{"location":"introduction/funtional-concepts/","title":"Functional Concepts","text":""},{"location":"introduction/memory-management/","title":"Memory Management","text":""},{"location":"introduction/rust-in-15-minutes/","title":"Rust In 15 Minutes","text":"<p>Examples showing the syntax and basic concepts of the Rust programming language.  Consider this a sneak peak for the rest of the book.</p> <p>NOTE: Rust Tutorial video series provides an in-depth introduction to Rust (or read the rest of this book)</p>"},{"location":"introduction/rust-in-15-minutes/#local-variables","title":"Local variables","text":"<p>Assign a value to a local variable using <code>let</code> inside a function or procedure</p> <pre><code>fn main() {\n  let myName = \"Nishant\"; // Rust infers type to be String\n  let coins: u32 = 4; // explicit type, unsigned 32-bit integer\n\n  let age = 19; // number defaults to i32 type, signed 32-bit integer\n}\n</code></pre> <p>Variables are immutable unless the <code>mut</code> type is explicitly included</p> <pre><code>fn main() {\n  let mut age = 21;\n}\n</code></pre> <p>NOTE: rust compiler will warn if a variable doesnt need to be mutable or if it is unused.</p> <p>NOTE: use <code>const</code> for a 'shared' variable</p> <p>If we declare a variable, and we try to use it without initializing, the Rust compiler will complain.</p> <pre><code>// * WILL NOT COMPILE\nfn main() {\n  let coins: u32;\n  foobar(coins);\n}\n\nfn foobar(num: u32) {\n  println!(\"The number sent was {}\", num);\n}\n</code></pre> <pre><code>Compiling hello_cargo v0.1.0 (/home/nishant/Programming/Rust/hello_cargo)\nerror[E0381]: used binding `coins` isn't initialized\n --&gt; src/main.rs:3:9\n  |\n2 |     let coins: u32;\n  |         ----- binding declared here but left uninitialized\n3 |     foobar(coins);\n  |            ^^^^^ `coins` used here but it isn't initialized\n  |\nhelp: consider assigning a value\n  |\n2 |     let coins: u32 = 0;\n  |                    +++\n\nFor more information about this error, try `rustc --explain E0381`.\nerror: could not compile `hello_cargo` due to previous error\n</code></pre> <p>As Rust programmers, we must read all error messages fully. The error message here tells us that we have used coins but we haven\u2019t initialized it. The message goes on to say that in line 2, we should append = 0 in order for the code to work!</p> <p>There are many data types used in Rust. We have come across String, i32 and u32. We also have,</p> <pre><code>fn main() {\n  let temperature: f32 = 6.4;\n  let circumference: f64 = 23053.7106;\n\n  let grade: char = 'A';\n  let pass: bool = true;\n}\n</code></pre>"},{"location":"introduction/rust-in-15-minutes/#mutation","title":"Mutation","text":"<p>All symbols are immutable unless marked with <code>mut</code> for mutation.</p> <p>When a symbol is declared mutable, care should be taken to assign it of the same type.</p>"},{"location":"introduction/rust-in-15-minutes/#constants","title":"Constants","text":"<pre><code>const welcome_message = \"Welcome to the wonderful world of Rust\";\n</code></pre> <p>Constant items - Rust-Lang</p>"},{"location":"introduction/rust-in-15-minutes/#compound-data-types","title":"Compound data types","text":"<p>Those above were some more primitive data types. Rust has support for compound data types as well!</p> <pre><code>fn main() {\n  let pair = ('A', 65);\n\n  println!(pair.0) // Accessing first element\n  println!(pair.1) // Accessing second element\n\n  // Destructuring a pair.\n  let (letter, number) = pair\n}\n</code></pre> <p>The implicit type for pair is (char, i32). Tuples are heterogeneous and can support nested tuples as well.</p> <p>Additionally, we can work with Arrays as well,</p> <pre><code>fn main() {\n  let a = [1, 2, 3, 4, 5];\n  // a has a type [i32; 5] - an array of five signed 32-bit integers.\n}\n</code></pre> <p>A data type declaration can hint towards a quick way to initialize arrays.</p> <pre><code>fn main() {\n  let a = [3; 5];\n\n  for i in a {\n    println!(\"{i}\");\n  }\n}\n\n// This program will print 3 on five lines.\n</code></pre>"},{"location":"introduction/rust-in-15-minutes/#functions","title":"Functions","text":"<p>We have seen we have been using the main function to denote the starting point in our program. The syntax of defining functions is</p> <pre><code>fn &lt;function-name&gt;(&lt;param-name&gt;: &lt;param-type&gt;) -&gt; &lt;return-type&gt; {\n  body\n}\n\nAn example function can be like:\n\nfn is_divisible(num: i32, dividend: i32) -&gt; bool {\n  num % dividend == 0\n}\n</code></pre> <p>Notice I do not have a semicolon at the end of that statement. This signifies that the expression will return a particular value. If I add a semicolon, Rust will treat the expression as a statement and will complain I am not returning a boolean value.</p>"},{"location":"introduction/rust-in-15-minutes/#procedures","title":"Procedures","text":"<p>Procedures are functions that do not return a value</p> <pre><code>fn &lt;Procedure-name&gt;(&lt;param-name&gt;: &lt;param-type&gt;) {\n  body\n}\n\nAn example function can be like:\n\nfn output_results(num: i32, dividend: i32) {\n    println!(num % dividend == 0);\n}\n</code></pre>"},{"location":"introduction/rust-in-15-minutes/#let-expressions","title":"Let Expressions","text":"<p>Combining the knowledge of variables and functions, we can assign values like this:</p> <pre><code>let x = {\n  let y = 1;\n  let z = 2;\n\n  y + z // Note the lack of semicolon to indicate return value\n}\n</code></pre> <p>Hence, we can conclude that:</p> <pre><code>fn main() {\n  let x = 0;\n  let x = { 0 }; // these two are the same!\n}\n</code></pre>"},{"location":"introduction/rust-in-15-minutes/#variable-shadowing-and-scopes","title":"Variable Shadowing and Scopes","text":"<p>Notice how I didn\u2019t prefix the previous code block with // * WILL NOT COMPILE. However, I do have two declarations of the same variable. This is called variable shadowing.</p> <pre><code>fn main() {\n  let x = 0;\n  let x = { 10 }; // shadowed the previous value of x\n}\n</code></pre> <p>First we initialize x to be 0, and then I am re-initializing it to be 10. This is a valid program and useful in many ways when we couple it with scopes!</p> <p>Scopes are just a block of code where shadowed variables do not affect the value of the variable outside the scope.</p> <pre><code>fn main () {\n  let x = 4;\n\n  {\n    let x = \"shadowing x\";\n    println!(\"{}\", x); // pfints \"shadowing x\"\n  }\n\n  println!(\"{}\", x); // prints \"4\"\n}\n</code></pre>"},{"location":"introduction/rust-in-15-minutes/#namespaces","title":"Namespaces","text":"<p>If we wish to use functions from other libraries, we can use namespaces.</p> <pre><code>fn main() {\n  let least = std::cmp::min(3, 8);\n\n  println!(\"{}\", least);\n}\n</code></pre> <p>We can also bring the function into scope by using the use keyword.</p> <pre><code>use std::cmp::min;\n\nfn main() {\n  let least = min(3, 8);\n\n  println!(\"{}\", least);\n}\n</code></pre> <p>Use <code>std::cmp::*</code> to bring every function inside <code>std::cmp</code> into scope.</p>"},{"location":"introduction/rust-in-15-minutes/#structs","title":"Structs","text":"<p>Define a struct Coordinate and initialize a variable of that type.</p> <pre><code>struct Coordinate {\n  x: f64,\n  y: f64\n}\n\nfn main() {\n  let somewhere = Coordinate { x: 23, y: 3.5 };\n\n  // Spreading the values of somewhere and updating x to 5.4\n  // make sure that ..somewhere is at the end.\n  let elsewhere = Coordinate { x: 5.4, ..somwhere };\n\n  // Destructuring Coordinate.\n  let Coordinate {\n    x,\n    y\n  } = elsewhere;\n}\n</code></pre> <p>Implement a functions for the struct</p> <pre><code>impl Coordinate {\n  fn add(self, coord: Coordinate) -&gt; Coordinate {\n    let newX = self.x + coord.x;\n    let newY = self.y + coord.y;\n\n    Coordinate { x: newX, y: newY }\n  }\n}\n</code></pre>"},{"location":"introduction/rust-in-15-minutes/#pattern-matching","title":"Pattern Matching","text":"<p>Pattern Matching is like a conditional structure.</p> <pre><code>fn main() {\n  let coordinate = Coordinate { x: 3.0, y: 5.0 }\n\n  if let Coordinate { x: 3.0, y } = coordinate {\n    println!(\"(3, {})\", y);\n  } else {\n    println!(\"x != three\");\n  }\n}\n</code></pre> <p>We can also perform pattern matching using the match construct.</p> <pre><code>fn main() {\n  let coordinate = Coordinate { x: 3.0, y: 5.0 }\n\n  match coordinate {\n    Coordinate { x: 3.0, y } =&gt; println!(\"(3, {})\", y);\n    _ =&gt; println!(\"x != three\");\n  }\n}\n</code></pre> <p>Alternatively, this code also compiles:</p> <pre><code>fn main() {\n  let coordinate = Coordinate { x: 3.0, y: 5.0 }\n\n  match coordinate {\n    Coordinate { x: 3.0, y } =&gt; println!(\"(3, {})\", y);\n    Coordinate { .. } =&gt; println!(\"x != three\");\n  }\n}\n</code></pre> <p><code>..</code> means ignore the (remaining) properties inside the Coordinate struct.</p>"},{"location":"introduction/rust-in-15-minutes/#traits","title":"Traits","text":"<p>Traits are like type classes in Haskell, or interfaces in Java. Say that we have a struct, Number which looks like this:</p> <pre><code>struct Number {\n  value: isize,\n  prime: bool\n}\n</code></pre> <p>We could define a trait Parity that contains a function is_even. If we implement Parity for Number, we need to define the trait\u2019s functions.</p> <pre><code>trait Parity {\n  fn is_even(self) -&gt; bool\n}\n\nimpl Parity for Number {\n  fn is_even(self) -&gt; bool {\n    self.value % 2 == 0\n  }\n}\n</code></pre> <p>We can also implement traits for foreign types as well!</p> <pre><code>// Using our struct for foreign type\nimpl Parity for i32 {\n  fn is_even(self) -&gt; bool {\n    self % 2 == 0\n  }\n}\n\n// Using foriegn trait for our struct\nimpl std::ops:Neg for Number {\n  type Output = Number;\n\n  fn neg(self) -&gt; Self::Output {\n    Number {\n      value: -self.value\n      ..self\n    }\n  }\n}\n</code></pre> <p>Foreign traits cannot be defined for foreign structs</p> <pre><code>// * WILL NOT COMPILE\nimpl&lt;T&gt; std::ops::Neg for Vec&lt;T&gt; {\n  type Output = isize;\n\n  fn neg(self) -&gt; Self::Output {\n    -self.len()\n  }\n}\n</code></pre>"},{"location":"introduction/rust-in-15-minutes/#macros","title":"Macros","text":"<p>Macros are a part of meta-programming. Marcos can be considered as little programs that other programs can use. All macros end with ! and can be defined as either of the following:</p> <pre><code>macro_name!()\nmacro_name!{}\nmacro_name![]\n</code></pre> <p><code>println!</code> is a macro that uses <code>std::io</code> to write to the console.</p> <p><code>vec![]</code> defines a vector, an array like structure</p> <pre><code>fn main() {\n  let vec1 = vec![1,2,3];\n\n  for number in vec1 {\n    println!(\"{number}\");\n  }\n}\n</code></pre> <p><code>panic!</code> is a macro that terminates a program Thread with an error message. <code>panic!</code> is one of the only places code can crash.</p>"},{"location":"introduction/rust-in-15-minutes/#enums","title":"Enums","text":"<p>Enums are types that are defined in an enclosure. The following example is coupled with Generics. Option is also defined in the standard library.</p> <pre><code>enum Option&lt;T&gt; {\n  None,\n  Some(T)\n}\n\nimpl Option&lt;T&gt; {\n  unwrap() -&gt; T {\n    match self {\n      Self::None -&gt; panic!(\"unwrap called on an Option None\"),\n      Self::Some -&gt; T,\n    }\n  }\n}\n</code></pre>"},{"location":"introduction/rust-in-15-minutes/#the-result-enum","title":"The Result enum","text":"<p>Rust provides the enum <code>Result</code>.</p> <pre><code>enum Result&lt;T, E&gt; {\n  Ok(T),\n  Err(E)\n}\n</code></pre> <p>When a function returns a result, we can safely handle it.</p> <pre><code>fn main() {\n  {\n    let result = do_something(); // returns result\n\n    match result {\n      Ok(data) =&gt; proceed(data),\n      Err(error) =&gt; panic!(\"There has been an error!\"),\n    }\n\n    // continue program execution\n  }\n}\n</code></pre> <p>The reason I have used this code within a scope block is if we wish to propagate the error up somewhere, we could replace the code with:</p> <pre><code>fn main() {\n  {\n    let result = do_something(); // returns result\n\n    match result {\n      Ok(data) =&gt; proceed(data),\n      Err(error) =&gt; return error,\n    }\n\n    // continue program execution\n  }\n}\n</code></pre> <p>There is a shorthand to do this operation:</p> <pre><code>fn main() {\n  {\n    let data = do_something()?; // returns result\n\n    // work with data directly\n  }\n}\n</code></pre> <p>Now if result returns an <code>Ok(data)</code>, then the question mark will return the data object to us.</p>"},{"location":"introduction/rust-workflow/","title":"Rust Workflow","text":"<ul> <li>Create project</li> <li>Open in Editor</li> <li>Define dependencies</li> <li>build, run, code</li> </ul>"},{"location":"introduction/rust-workflow/#evaluation","title":"Evaluation","text":"<p>Rust does not provide a REPL however it could be possible to create one.</p> <p>... is a very basic script that evaluates code agains the Rust Playground API.</p> <p>NOTE: Is should be possible to send Rust forms to the compiler and get a result. Perhaps an implementation of nREPL protocol or similar would be valuable?</p>"},{"location":"introduction/rust-workflow/#testing","title":"Testing","text":""},{"location":"introduction/rust-workflow/#nextest","title":"Nextest","text":"<p>Nextest is a Next-gen test runner for Rust.</p> <p>Up to 3 times faster than <code>cargo test</code></p> <ul> <li>nextest-runner: core logic for cargo-nextest</li> <li>nextest-metadata: library for calling cargo-nextest over the command line</li> <li>nextest-filtering: parser and evaluator for filtersets</li> </ul>"},{"location":"learn/","title":"Learn Rust","text":"<p>Learning any programming language involves (in no specific order)</p> <ul> <li>understanding the syntax</li> <li>absorbing the concepts the language is built upon</li> <li>establishing an effective development workflow</li> <li>discovering idioms and patterns</li> <li>practice, practice, practice</li> </ul>"},{"location":"learn/#syntax","title":"Syntax","text":"<p>The Rust Book</p>"},{"location":"learn/#practice-practice-practice","title":"Practice Practice Practice","text":"<p>Rustlings small exercises to support reading and writing Rust (use in parallel with the Rust book).</p> <p>Exercism - Rust track challenges to practice rust (includes on-line mentor support)</p> <p>Rust Tutorial video series for an in-depth introduction to the language</p> <p>Rust online playground</p> <p>Rust local playground calls the Rust Playground API from your terminal (not the same as a Clojure REPL).</p>"},{"location":"learn/#additional-resources","title":"Additional Resources","text":"<p>TODO: review resources for learning rust</p> <p>How to learn Rust in 2025 - Jetbrains</p> <p>Rust Primer - Code Crafters</p> <p>Gentle intro to Rust</p> <p>Rust Primer for writing CLIs</p>"},{"location":"projects/","title":"Projects","text":"<p>Cargo package manager is use to create and work with Rust projects.</p> <p>Templates can be used to bootstrap new rust projects.</p>"},{"location":"projects/#command-reference","title":"Command reference","text":"Command Description <code>cargo new project-name</code> Create a new rust project with given name <code>cargo build</code> Build rust project, resolving library dependencies <code>cargo run</code> Run Rust project <code>cargo test</code> Run test runner for Rust project <code>cargo doc</code> Generate Project documentation <code>cargo publish</code> Publish library to crates.io"},{"location":"projects/#create-a-new-rust-project","title":"Create a new rust project","text":"<pre><code>cargo new project-name\n</code></pre> <pre><code>\u276f cargo new playground\n    Creating binary (application) `playground` package\nnote: see more `Cargo.toml` keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\n</code></pre> <p>Project structure</p> <pre><code>\u276f tree playground\nplayground\n\u251c\u2500\u2500 Cargo.toml\n\u2514\u2500\u2500 src\n    \u2514\u2500\u2500 main.rs\n\n2 directories, 2 files\n</code></pre>"},{"location":"projects/#library-dependencies","title":"Library Dependencies","text":"<p><code>Cargo.toml</code> file in the root of a project is used to define library dependencies for the project.</p> <p>Define a dependency with its name and version.</p> <pre><code>[dependencies]\nferris-says = \"0.3.2\"\n</code></pre> <p><code>Cargo.lock</code> contains a log of the specific versions of dependencies for the project, created and updated by the <code>cargo build</code> command.</p> <p>Make the library available with the <code>use</code> directive</p> <pre><code>use ferris_says::say;\nuse std::io::{stdout, BufWriter};\n\nfn main() {\n    let out = \"Hello fellow Rustaceans!\";\n    let width = 24;\n\n    let mut writer = BufWriter::new(stdout());\n    say(out, width, &amp;mut writer).unwrap();\n}\n</code></pre> <p><code>cargo run</code> will execute the <code>main</code> function and return the result (if there is one).</p>"},{"location":"projects/guides/","title":"Guides","text":"<p>Step by step practical guide to building applications and services with Rust.</p> <ul> <li>Rest API with Axum and OpenAPI</li> </ul>"},{"location":"projects/guides/rest-api/","title":"Rest API with Swagger UI","text":"<p>Create an API service that provides a documented and interactive API using Open API.</p> <p>Axum is the web framework, supported by Tokio async runtime and Serde for JSON serialisation.</p> Background references <p>What is a runtime in Rust</p> <p>How to implement an async main function</p> <p>NOTE: other web frameworks include Rocket, Warp, Actix</p>"},{"location":"projects/guides/rest-api/#create-project","title":"Create project","text":"<p>Create a basic project using the Cargo tool.</p> <pre><code>cargo new hello-world --bin\n</code></pre> Project configuration file <pre><code>[package]\nname = \"hello-world\"\nversion = \"0.1.0\"\nedition = \"2024\"\n\n[dependencies]\n</code></pre>"},{"location":"projects/guides/rest-api/#dependencies","title":"Dependencies","text":"<p>Add library dependencies for Axium and other useful libraries Cargo.toml<pre><code>[dependencies]\naxum = \"0.8\"\ntokio = { version = \"1.22.0\", features = [\"full\"] }\nserde = { version = \"1.0.149\", features = [\"derive\"] }\n</code></pre></p> <p>Updating Crates</p> <p>LSP / Rustaceannvim will automatically detect newer versions of creates available.</p> <p><code>SPC l a</code> to select the \"Update creates\" code action.  Or select \"Update all creates\" action if there are multiple creates with newer versions.</p>"},{"location":"projects/guides/rest-api/#create-a-web-server","title":"Create a web server","text":"<p>Use the Rust standard library to define IP address for the web server and manage errors.</p> <p>Use axum to define a router and routes to handle requests.</p> <p>Edit the <code>src/main.rs</code> and replace the existing code</p> <pre><code>use std::{error::Error, net::SocketAddr};\n\nuse axum::{\n    routing::get,\n    Router,\n};\n\n#[tokio::main]\nasync fn main() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {\n    let addr = SocketAddr::from(([127, 0, 0, 1], 8000));\n\n    let app = Router::new().route(\"/\", get(|| async { \"Hello, Axum\" }));\n\n    println!(\"listening on {}\", addr);\n\n    axum::Server::bind(&amp;addr)\n        .serve(app.into_make_service())\n        .await\n        .unwrap();\n\n    Ok(())\n}\n</code></pre>"},{"location":"projects/guides/rest-api/#run-and-test-web-server","title":"Run and test web server","text":"<p>Start the Rust project in watch mode, so changes are automatically updated on save.</p> <p>Install Bacon</p> <pre><code>cargo install --locked bacon\n</code></pre> <p>NOTE: bacon has a long list of crate library dependencies... downloading the internet!</p> <pre><code>cargo run\n</code></pre> Bacon is the new cargo watch <p>Cargo-watch is no longer maintained, recommends bacon the background code checker instead.</p>"},{"location":"reference/","title":"Reference","text":""},{"location":"reference/books/","title":"Rust Books","text":"<p>Learn Rust aka 'The Rust Book'.</p> <p>Idioomatic Rust covers design patterns for using rust effectively (video edition - author reading book)</p>"},{"location":"reference/books/#video","title":"Video","text":""}]}